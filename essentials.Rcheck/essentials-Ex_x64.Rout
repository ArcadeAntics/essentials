
R version 4.1.2 (2021-11-01) -- "Bird Hippie"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-w64-mingw32/x64 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "essentials"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> options(pager = "console")
> base::assign(".ExTimings", "essentials-Ex.timings", pos = 'CheckExEnv')
> base::cat("name\tuser\tsystem\telapsed\n", file=base::get(".ExTimings", pos = 'CheckExEnv'))
> base::assign(".format_ptime",
+ function(x) {
+   if(!is.na(x[4L])) x[1L] <- x[1L] + x[4L]
+   if(!is.na(x[5L])) x[2L] <- x[2L] + x[5L]
+   options(OutDec = '.')
+   format(x[1L:3L], digits = 7L)
+ },
+ pos = 'CheckExEnv')
> 
> ### * </HEADER>
> library('essentials')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("ASCII")
> ### * ASCII
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ASCII
> ### Title: ASCII Characters
> ### Aliases: ASCII
> 
> ### ** Examples
> 
> ASCII()
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font width unknown for character 0x1
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font metrics unknown for character 0x1
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font width unknown for character 0x2
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font metrics unknown for character 0x2
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font width unknown for character 0x3
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font metrics unknown for character 0x3
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font width unknown for character 0x4
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font metrics unknown for character 0x4
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font width unknown for character 0x5
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font metrics unknown for character 0x5
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font width unknown for character 0x6
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font metrics unknown for character 0x6
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font width unknown for character 0x7
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font metrics unknown for character 0x7
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font width unknown for character 0x8
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font metrics unknown for character 0x8
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font width unknown for character 0x9
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font metrics unknown for character 0x9
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font width unknown for character 0xb
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font metrics unknown for character 0xb
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font width unknown for character 0xc
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font metrics unknown for character 0xc
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font width unknown for character 0xd
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font metrics unknown for character 0xd
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font width unknown for character 0xe
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font metrics unknown for character 0xe
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font width unknown for character 0xf
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font metrics unknown for character 0xf
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font width unknown for character 0x10
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font metrics unknown for character 0x10
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font width unknown for character 0x11
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font metrics unknown for character 0x11
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font width unknown for character 0x12
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font metrics unknown for character 0x12
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font width unknown for character 0x13
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font metrics unknown for character 0x13
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font width unknown for character 0x14
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font metrics unknown for character 0x14
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font width unknown for character 0x15
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font metrics unknown for character 0x15
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font width unknown for character 0x16
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font metrics unknown for character 0x16
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font width unknown for character 0x17
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font metrics unknown for character 0x17
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font width unknown for character 0x18
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font metrics unknown for character 0x18
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font width unknown for character 0x19
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font metrics unknown for character 0x19
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font width unknown for character 0x1a
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font metrics unknown for character 0x1a
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font width unknown for character 0x1b
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font metrics unknown for character 0x1b
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font width unknown for character 0x1c
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font metrics unknown for character 0x1c
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font width unknown for character 0x1d
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font metrics unknown for character 0x1d
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font width unknown for character 0x1e
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font metrics unknown for character 0x1e
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font width unknown for character 0x1f
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font metrics unknown for character 0x1f
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font width unknown for character 0x7f
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font metrics unknown for character 0x7f
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  conversion failure on '€' in 'mbcsToSbcs': dot substituted for <e2>
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  conversion failure on '€' in 'mbcsToSbcs': dot substituted for <82>
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  conversion failure on '€' in 'mbcsToSbcs': dot substituted for <ac>
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font metrics unknown for Unicode character U+20ac
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  conversion failure on '€' in 'mbcsToSbcs': dot substituted for <e2>
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  conversion failure on '€' in 'mbcsToSbcs': dot substituted for <82>
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  conversion failure on '€' in 'mbcsToSbcs': dot substituted for <ac>
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font width unknown for character 0x81
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font metrics unknown for character 0x81
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  conversion failure on '†' in 'mbcsToSbcs': dot substituted for <e2>
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  conversion failure on '†' in 'mbcsToSbcs': dot substituted for <80>
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  conversion failure on '†' in 'mbcsToSbcs': dot substituted for <a0>
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font metrics unknown for Unicode character U+2020
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  conversion failure on '†' in 'mbcsToSbcs': dot substituted for <e2>
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  conversion failure on '†' in 'mbcsToSbcs': dot substituted for <80>
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  conversion failure on '†' in 'mbcsToSbcs': dot substituted for <a0>
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  conversion failure on '‡' in 'mbcsToSbcs': dot substituted for <e2>
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  conversion failure on '‡' in 'mbcsToSbcs': dot substituted for <80>
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  conversion failure on '‡' in 'mbcsToSbcs': dot substituted for <a1>
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font metrics unknown for Unicode character U+2021
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  conversion failure on '‡' in 'mbcsToSbcs': dot substituted for <e2>
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  conversion failure on '‡' in 'mbcsToSbcs': dot substituted for <80>
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  conversion failure on '‡' in 'mbcsToSbcs': dot substituted for <a1>
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  conversion failure on '‰' in 'mbcsToSbcs': dot substituted for <e2>
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  conversion failure on '‰' in 'mbcsToSbcs': dot substituted for <80>
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  conversion failure on '‰' in 'mbcsToSbcs': dot substituted for <b0>
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font metrics unknown for Unicode character U+2030
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  conversion failure on '‰' in 'mbcsToSbcs': dot substituted for <e2>
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  conversion failure on '‰' in 'mbcsToSbcs': dot substituted for <80>
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  conversion failure on '‰' in 'mbcsToSbcs': dot substituted for <b0>
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font width unknown for character 0x8d
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font metrics unknown for character 0x8d
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font width unknown for character 0x8f
Warning in text.default(x = rep(xvals, 16), y = rep(yvals, each = 16), labels = c(NA,  :
  font metrics unknown for character 0x8f
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ASCII", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("Args")
> ### * Args
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: Args
> ### Title: Extract Arguments Supplied to a Script / / From an Object of
> ###   Class "ParsedArgs"
> ### Aliases: Args
> 
> ### ** Examples
> 
> essentials:::write.code(file = FILE <- tempfile(), withAutoprint({
+ 
+ 
+     # the regular command-line arguments
+     commandArgs()
+ 
+ 
+     # the script arguments
+     essentials::Args()
+ 
+ 
+ }, verbose = FALSE))
> 
> 
> essentials::Rscript("--default-packages=NULL", FILE, args = pi)
andre@DESKTOP-VR312SR:~/essentials/essentials.Rcheck/examples_x64$ Rscript "--default-packages=NULL" "C:\Users\andre\AppData\Local\Temp\Rtmpm4mB3T/working_dir\RtmpmATTxt\file43b45d145ab9" "3.1415926535897931"
> commandArgs()
[1] "C:\\PROGRA~1\\R\\R-4.1.2\\bin\\x64\\Rterm.exe"                                                      
[2] "--no-echo"                                                                                          
[3] "--no-restore"                                                                                       
[4] "--file=C:\\Users\\andre\\AppData\\Local\\Temp\\Rtmpm4mB3T/working_dir\\RtmpmATTxt\\file43b45d145ab9"
[5] "--args"                                                                                             
[6] "3.1415926535897931"                                                                                 
> essentials::Args()
[1] "3.1415926535897931"

Process finished with exit code 0
> essentials::withArgs(source(FILE, verbose = FALSE), pi)
> commandArgs()
 [1] "C:\\PROGRA~1\\R\\R-4.1.2\\bin\\x64\\Rterm.exe"                                
 [2] "LANGUAGE=en"                                                                  
 [3] "_R_CHECK_INTERNALS2_=1"                                                       
 [4] "R_ENVIRON_USER='no_such_file'"                                                
 [5] "R_LIBS=C:\\Users\\andre\\AppData\\Local\\Temp\\Rtmpm4mB3T\\RLIBS_16042c443580"
 [6] "R_ENVIRON_USER='no_such_file'"                                                
 [7] "R_LIBS_USER='no_such_dir'"                                                    
 [8] "R_LIBS_SITE='no_such_dir'"                                                    
 [9] "--no-site-file"                                                               
[10] "--no-init-file"                                                               
[11] "--no-save"                                                                    
[12] "--no-restore"                                                                 
[13] "-f"                                                                           
[14] "../essentials-Ex.R"                                                           
> essentials::Args()
[1] "3.1415926535897931"
> 
> 
> unlink(FILE)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("Args", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ArgumentParser")
> ### * ArgumentParser
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ArgumentParser
> ### Title: Argument Parser
> ### Aliases: ArgumentParser ArgumentParser-class
> ###   essentials_ArgumentParser-class
> 
> ### ** Examples
> 
> x <- essentials::ArgumentParser()
> x$print.help()
Usage: essentials-Ex.R [arguments]

Arguments:
  -h, --help  Print usage message and exit
> 
> 
> y <- essentials::ArgumentParser(description = "A description for the program",
+     epilogue = c("  --- Final Message ---   ",
+         "A final message for the program, do not wrap this message"),
+     wrap.epilogue = FALSE)
> y$print.help()
Usage: essentials-Ex.R [arguments]

A description for the program

Arguments:
  -h, --help  Print usage message and exit

  --- Final Message ---   
A final message for the program, do not wrap this message
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ArgumentParser", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("Commands")
> ### * Commands
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: Commands
> ### Title: Extract Commands From an Object of Class "ParsedArgs"
> ### Aliases: Commands
> 
> ### ** Examples
> 
> parser <- essentials::ArgumentParser()
> `parser CMD1` <- parser$add.parser("CMD1")
> `parser CMD2` <- parser$add.parser("CMD2")
> `parser CMD1 a` <- `parser CMD1`$add.parser(c("a", "b"))
> `parser CMD1 c` <- `parser CMD1`$add.parser(c("c", "d"))
> `parser CMD2 e` <- `parser CMD2`$add.parser(c("e", "f"))
> `parser CMD2 g` <- `parser CMD2`$add.parser(c("g", "h"))
> 
> 
> essentials::Commands(parser$parse.args())
character(0)
> essentials::Commands(parser$parse.args(c("CMD1")))
[1] "CMD1"
> essentials::Commands(parser$parse.args(c("CMD2")))
[1] "CMD2"
> essentials::Commands(parser$parse.args(c("CMD1", "a")))
[1] "CMD1" "a"   
> essentials::Commands(parser$parse.args(c("CMD1", "b")))
[1] "CMD1" "a"   
> essentials::Commands(parser$parse.args(c("CMD1", "c")))
[1] "CMD1" "c"   
> essentials::Commands(parser$parse.args(c("CMD1", "d")))
[1] "CMD1" "c"   
> essentials::Commands(parser$parse.args(c("CMD2", "e")))
[1] "CMD2" "e"   
> essentials::Commands(parser$parse.args(c("CMD2", "f")))
[1] "CMD2" "e"   
> essentials::Commands(parser$parse.args(c("CMD2", "g")))
[1] "CMD2" "g"   
> essentials::Commands(parser$parse.args(c("CMD2", "h")))
[1] "CMD2" "g"   
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("Commands", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("GeneralizedExtremeValue")
> ### * GeneralizedExtremeValue
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: GeneralizedExtremeValue
> ### Title: The Generalized Extreme Value Distribution
> ### Aliases: GeneralizedExtremeValue dgev pgev qgev rgev
> 
> ### ** Examples
> 
> shapes <- expression(-1/2, 0, +1/2)
> legend.text <- as.expression(lapply(shapes, function(shape) {
+     call("==", as.symbol("xi"), shape)
+ }))
> shapes <- vapply(shapes, base::eval, 0)
> cols <- c("green3", "red", "blue")
> x <- seq.int(-4, 4, length.out = 1001)
> 
> 
> # we use plapply here instead of lapply because
> # plapply allows us to name the looping arguments
> y <- essentials::plapply(
+     list(shape = shapes),
+     essentials::dgev,
+     x = x
+ )
> graphics::par(mar = c(4.9, 4.5, 2.1, 0.4))
> graphics::plot(
+     xlim = range(x), ylim = range(y),
+     panel.first = graphics::grid(col = "gray69"),
+     x = NA_real_, y = NA_real_,
+     xlab = "x", ylab = ~f(list(x, mu, sigma, xi)),
+     main = "Probability density function",
+     bty = "L"
+ )
> for (i in seq_along(y)) {
+     graphics::lines(x, y[[i]], col = cols[[i]], lwd = 2)
+ }
> graphics::legend(
+     x = "topleft",
+     legend = legend.text,
+     col = cols,
+     lwd = 2,
+     bty = "n"
+ )
> graphics::title(sub = ~"All with" ~ list(mu == 0, sigma == 1), adj = 1)
> 
> 
> 
> 
> 
> y <- essentials::plapply(
+     list(shape = shapes),
+     essentials::pgev,
+     q = x
+ )
> graphics::plot(
+     xlim = range(x), ylim = range(y),
+     panel.first = graphics::grid(col = "gray69"),
+     x = NA_real_, y = NA_real_,
+     xlab = "x", ylab = ~F(list(x, mu, sigma, xi)),
+     main = "Cumulative probability function",
+     bty = "L"
+ )
> for (i in seq_along(y)) {
+     graphics::lines(x, y[[i]], col = cols[[i]], lwd = 2)
+ }
> graphics::legend(
+     x = "topleft",
+     legend = legend.text,
+     col = cols,
+     lwd = 2,
+     bty = "n"
+ )
> graphics::title(sub = ~"All with" ~ list(mu == 0, sigma == 1), adj = 1)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("GeneralizedExtremeValue", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("IDW")
> ### * IDW
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: InverseDistanceWeighting
> ### Title: Inverse Distance Weighting
> ### Aliases: InverseDistanceWeighting IDW
> 
> ### ** Examples
> 
> x0 <- c(0, 1, 4, 5)
> u0 <- c(1, 2, 2, 1)
> x <- seq.int(-4, 9, length.out = 1001)
> u <- IDW(x0, u0, x)
> graphics::plot(
+     panel.first = graphics::grid(col = "gray69"),
+     x, u, type = "l", col = "blue", lwd = 2
+ )
> graphics::points(x0, u0, pch = 16, cex = 1.5)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("IDW", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("Missing")
> ### * Missing
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: Missing
> ### Title: Does an Argument have a Value?
> ### Aliases: Missing
> 
> ### ** Examples
> 
> parser <- essentials::ArgumentParser()
> parser$add.argument("--arg1")
> parser$add.argument("--arg2", default = "def")
> pargs <- parser$parse.args()
> 
> 
> list(
+     arg1 = essentials::Missing(pargs, arg1),
+     arg2 = essentials::Missing(pargs, "arg2")
+ )
$arg1
[1] TRUE

$arg2
[1] FALSE

> 
> 
> # with R >= 4.1.0, use the forward pipe operator `|>` to
> # make calls to `Missing` more intuitive:
> # list(
> #     arg1 = pargs |> essentials::Missing(arg1),
> #     arg2 = pargs |> essentials::Missing("arg2")
> # )
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("Missing", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("R")
> ### * R
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: R
> ### Title: Start a New R Session
> ### Aliases: R Rcmd Rscript Rterm
> 
> ### ** Examples
> 
> # if you're on Windows, you should notice that the quoting rules for 'Rterm' are
> # far more intuituve than for 'R'
> #
> # if you're under a Unix-alike, you should notice that 'Rterm' and 'R' do the
> # same thing
> 
> 
> essentials::R      (exprs = r"{cat(commandArgs(), sep = "\n")}")
andre@DESKTOP-VR312SR:~/essentials/essentials.Rcheck/examples_x64$ R -e "cat(commandArgs(), sep = \\\"\n\\\")"

R version 4.1.2 (2021-11-01) -- "Bird Hippie"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-w64-mingw32/x64 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> cat(commandArgs(), sep = "\n")
C:\PROGRA~1\R\R-4.1.2/bin/x64/Rterm.exe
-e
cat(commandArgs(), sep = "\n")
> 
> 

Process finished with exit code 0
> essentials::Rterm  (exprs = r"{cat(commandArgs(), sep = "\n")}")
andre@DESKTOP-VR312SR:~/essentials/essentials.Rcheck/examples_x64$ Rterm -e "cat(commandArgs(), sep = \"\n\")"

R version 4.1.2 (2021-11-01) -- "Bird Hippie"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-w64-mingw32/x64 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> cat(commandArgs(), sep = "\n")
C:\PROGRA~1\R\R-4.1.2\bin\x64\Rterm.exe
-e
cat(commandArgs(), sep = "\n")
> 
> 

Process finished with exit code 0
> essentials::Rscript(exprs = r"{cat(commandArgs(), sep = "\n")}")
andre@DESKTOP-VR312SR:~/essentials/essentials.Rcheck/examples_x64$ Rscript -e "cat(commandArgs(), sep = \"\n\")"
C:\PROGRA~1\R\R-4.1.2\bin\x64\Rterm.exe
--no-echo
--no-restore
-e
cat(commandArgs(), sep = "\n")

Process finished with exit code 0
> essentials::Rscript(exprs = r"{cat(commandArgs(), sep = "\n")}", quiet = TRUE)
C:\PROGRA~1\R\R-4.1.2\bin\x64\Rterm.exe
--no-echo
--no-restore
-e
cat(commandArgs(), sep = "\n")
> 
> 
> essentials::Rcmd(command = "INSTALL", args = "--help")
andre@DESKTOP-VR312SR:~/essentials/essentials.Rcheck/examples_x64$ R CMD "INSTALL" "--help"
Usage: R CMD INSTALL [options] pkgs

Install the add-on packages specified by pkgs.  The elements of pkgs can
be relative or absolute paths to directories with the package
sources, or to gzipped package 'tar' archives.  The library tree
to install to can be specified via '--library'.  By default, packages are
installed in the library tree rooted at the first directory in
.libPaths() for an R session run in the current environment.

Options:
  -h, --help		print short help message and exit
  -v, --version		print INSTALL version info and exit
  -c, --clean		remove files created during installation
      --preclean	remove files created during a previous run
  -d, --debug		turn on debugging messages
			and build a debug DLL
  -l, --library=LIB	install packages to library tree LIB
      --no-configure    do not use the package's configure script
      --no-docs		do not install HTML, LaTeX or examples help
      --html		build HTML help
      --no-html		do not build HTML help
      --latex      	install LaTeX help
      --example		install R code for help examples
      --fake		do minimal install for testing purposes
      --no-lock		install on top of any existing installation
			without using a lock directory
      --lock		use a per-library lock directory (default)
      --pkglock		use a per-package lock directory
      			(default for a single package)
      --build    	build binaries of the installed package(s)
      --install-tests	install package-specific tests (if any)
      --no-R, --no-libs, --no-data, --no-help, --no-demo, --no-exec,
      --no-inst
			suppress installation of the specified part of the
			package for testing or other special purposes
      --no-multiarch	build only the main architecture
      --libs-only	only install the libs directory
      --data-compress=	none, gzip (default), bzip2 or xz compression
			to be used for lazy-loading of data
      --resave-data	re-save data files as compactly as possible
      --compact-docs	re-compress PDF files under inst/doc
      --with-keep.source
      --without-keep.source
			use (or not) 'keep.source' for R code
      --with-keep.parse.data
      --without-keep.parse.data
			use (or not) 'keep.parse.data' for R code
      --byte-compile	byte-compile R code
      --no-byte-compile	do not byte-compile R code
      --staged-install	install to a temporary directory and then move
                   	to the target directory (default)
      --no-staged-install	install directly to the target directory
      --no-test-load	skip test of loading installed package
      --no-clean-on-error	do not remove installed package on error
      --merge-multiarch	multi-arch by merging (from a single tarball only)
      --use-vanilla	do not read any Renviron or Rprofile files
      --use-LTO         use Link-Time Optimization
      --no-use-LTO      do not use Link-Time Optimization

for Unix
      --configure-args=ARGS
			set arguments for the configure scripts (if any)
      --configure-vars=VARS
			set variables for the configure scripts (if any)
      --strip           strip shared object(s)
      --strip-lib       strip static/dynamic libraries under lib/
      --dsym            (macOS only) generate dSYM directory
      --built-timestamp=STAMP
                   set timestamp for Built: entry in DESCRIPTION

and on Windows only
      --force-biarch	attempt to build both architectures
			even if there is a non-empty configure.win
      --compile-both	compile both architectures on 32-bit Windows

Which of --html or --no-html is the default depends on the build of R:
for this one it is --html.

Report bugs at <https://bugs.R-project.org>.

Process finished with exit code 0
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("R", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("Runge-KuttaMethods")
> ### * Runge-KuttaMethods
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: Runge-Kutta Methods
> ### Title: Runge-Kutta Methods
> ### Aliases: 'Runge-Kutta Methods' EulerMethod RK1 ImprovedEulerMethod RK2
> ###   RungeKuttaMethod RK4
> 
> ### ** Examples
> 
> # Consider a particle moving in a bowl
> # We'll use cylindrical coordinates r, theta, and z
> #     r     = radial position (distance from z-axis)
> #     theta = angular position
> #     z     = height
> # The height of the bowl is z = r
> # The independent variable (in this case) is time (denoted t)
> # After some calculations, the differential equations obtained are
> #     d/dt(r^2 * d/dt(theta)) = 0
> #     d^2/dt^2(r) = r/2 * (d/dt(theta))^2 - g/2
> # where g is the acceleration due to gravity
> # This gives us three equations as follows
> #     d/dt(r)     = f[r]     = rdot
> #     d/dt(rdot)  = f[rdot]  = (r * (d/dt(theta))^2 - g)/2
> #     d/dt(theta) = f[theta] = r0^2 * thetadot0 / r^2
> # where
> #     rdot      = d/dt(r)
> #     r0        = initial value of radial  position
> #     rdot0     = initial value of radial  velocity
> #     theta0    = initial value of angular position
> #     thetadot0 = initial value of angular velocity
> # With all of this information, we can define
> #     a sequence of time values
> #     our initial conditions
> #     derivatives of the dependents with respect to the independent
> 
> 
> g <- 1
> r0 <- 1           # 1 away from the center
> rdot0 <- 0        # not moving radially
> theta0 <- 0       # in the positive x-direction
> thetadot0 <- 0.5  # spinning counter-clockwise with angular speed 0.5
> 
> 
> k <- r0^2 * thetadot0
> thetadot <- function(r) k/r^2
> 
> 
> independent <- list(t = seq.int(0, 21.6, 0.001))
> initialConditions <- c(r = r0, rdot = rdot0, theta = theta0)
> fun <- function(independent, dependents) {
+     r <- dependents[1L]
+     thetadot <- k/r^2
+     c(dependents[2L], (r * thetadot^2 - g)/2, thetadot)
+ }
> 
> 
> # finally, simply call
> value <- essentials::EulerMethod(independent, initialConditions, fun)
> 
> 
> x <- value$r * cos(value$theta)
> y <- value$r * sin(value$theta)
> xylim <- c(-1, 1) * max(abs(c(x, y)))
> 
> 
> graphics::par(mar = c(5.1, 4.1, 0.4, 0.4))
> graphics::plot(
+     xlim = xylim, ylim = xylim, asp = 1,
+     panel.first = grid(col = "gray69"),
+     x = x, y = y,
+     col = grDevices::hcl.colors(length(x)),
+     pch = 16, cex = 0.5,
+     bty = "n",
+     xlab = "x", ylab = "y"
+ )
> graphics::title(
+     sub = bquote(list(
+         r[0] == .(r0),
+         dot(r)[0] == .(rdot0),
+         theta[0] == .(theta0),
+         dot(theta)[0] == .(thetadot0))
+     ),
+     adj = 1
+ )
> ## Don't show: 
> remove(g, r0, rdot0, theta0, thetadot0, k, independent, initialConditions, fun, value, x, y, xylim)
> ## End(Don't show)
> 
> 
> 
> 
> 
> 
> 
> 
> 
> # Consider an animal population defined by
> #     d/dt(P) = k * P * (M - P) - h
> # where
> #     t = time
> #     P = population as a function of time
> #     k = how fast the population increases
> #     M = carrying capacity of the population within their environment
> #     h = amount harvested / / hunted
> #
> #
> # The solution to this equation is
> #     P(t) = (M1 * (P0 - M2) - M2 * (P0 - M1) * exp(-k * Delta * t)) /
> #         ((P0 - M2) - (P0 - M1) * exp(-k * Delta * t))
> # where
> #     P0    = initial population
> #     Delta = sqrt(M^2 - 4 * h/k)
> #     M1    = (M + Delta)/2
> #     M2    = (M - Delta)/2
> # We will now compare the exact solution stated above
> # to the numerical solution from the Euler method
> 
> 
> k <- 1
> M <- 4
> h <- 3
> 
> 
> Delta <- sqrt(M^2 - 4 * h/k)
> M1    <- (M + Delta)/2
> M2    <- (M - Delta)/2
> 
> 
> exact <- function (P0, col)
+ {
+     t <- seq.int(0, 5, length.out = 101)
+     P <- (M1 * (P0 - M2) - M2 * (P0 - M1) * exp(-k * Delta * t)) /
+         ((P0 - M2) - (P0 - M1) * exp(-k * Delta * t))
+     graphics::lines(t, P, col = col, lwd = 2)
+     invisible()
+ }
> euler <- function (P0, col)
+ {
+     t <- seq.int(0, 5, 0.5)
+     initialConditions <- c(P = P0)
+     fun <- function(t, P) k * P * (M - P) - h
+     P <- essentials::EulerMethod(t, initialConditions, fun)$P
+     graphics::lines(t, P, col = col, lwd = 2)
+     invisible()
+ }
> 
> 
> P0 <- c(1.5, 2, 3.5)  # different values of initial population to plot
> exact_colours <- c("red"    , "green"    , "blue")
> euler_colours <- c("maroon4", "darkgreen", "navy")
> 
> 
> graphics::par(mar = c(5.1, 4.1, 0.4, 0.4))
> graphics::plot(
+     xlim = c(0, 5), ylim = c(1.5, 3.5),
+     panel.first = grid(col = "gray69"),
+     x = NA_real_, y = NA_real_,
+     bty = "n",
+     xlab = "time", ylab = "population"
+ )
> graphics::title(
+     sub = bquote(list(k == .(k), M == .(M), h == .(h))),
+     adj = 1
+ )
> for (i in seq_along(P0)) {
+     exact(P0[i], exact_colours[i])
+     euler(P0[i], euler_colours[i])
+ }
> graphics::legend("bottomright",
+     legend = as.expression(essentials::plapply(
+         list(
+             rep(c("Exact", "Euler"), each = length(P0)),
+             rep(P0, 2)
+         ),
+         function(name, P0) bquote(list(.(name), P[0] == .(P0)))
+     )),
+     fill   = c(exact_colours, euler_colours),
+     ncol   = 2,
+     bty = "n")## Don't show: 
> remove(k, M, h, Delta, M1, M2, exact, euler, P0, exact_colours, euler_colours, i)
> ## End(Don't show)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("Runge-KuttaMethods", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("as.colorRampPalette")
> ### * as.colorRampPalette
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: as.colorRampPalette
> ### Title: Color Interpolation
> ### Aliases: as.colorRampPalette
> 
> ### ** Examples
> 
> crp <- as.colorRampPalette(1:9)
> 
> show.colors(crp(20))
> 
> show.colors(crp(20, end = 19/20))
> 
> show.colors(crp(20, alpha = 0.75))
> 
> show.colors(crp(20, rev = TRUE))
> 
> show.colors(crp(20, end = 19/20, alpha = 0.75, rev = TRUE))
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("as.colorRampPalette", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("as.scalar")
> ### * as.scalar
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: as.scalar
> ### Title: Scalars
> ### Aliases: scalar as.scalar as.scalar.logical as.scalar.integer
> ###   as.scalar.real as.scalar.double as.scalar.numeric as.scalar.complex
> ###   as.scalar.number as.scalar.string as.scalar.character as.scalar.raw
> 
> ### ** Examples
> 
> ## if the type converting from and converting to are identical, as.scalar is a
> ## much shorter way of writing what you intend.
> as.scalar(c(TRUE, FALSE, NA))
[1] TRUE
> as.scalar(1:100)
[1] 1
> as.scalar(1:10 + 0.5)
[1] 1.5
> as.scalar(exp((0+1i) * 6 * (-4:4)))
[1] 0.424179+0.9055784i
> as.scalar(letters)
[1] "a"
> 
> 
> ## if the type converting from and converting to are not identical, it is better
> ## to specify the type converting to.
> as.scalar.logical(c(TRUE, FALSE, NA))
[1] TRUE
> as.scalar.integer(c(TRUE, FALSE, NA))
[1] 1
> as.scalar.numeric(c(TRUE, FALSE, NA))
[1] 1
> as.scalar.complex(c(TRUE, FALSE, NA))
[1] 1+0i
> as.scalar.character(c(TRUE, FALSE, NA))
[1] "TRUE"
> 
> as.scalar(TRUE, "character")
[1] "TRUE"
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("as.scalar", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("asWindowsbasename")
> ### * asWindowsbasename
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: asWindowsbasename
> ### Title: Create a Basename Valid in Windows
> ### Aliases: asWindowsbasename
> 
> ### ** Examples
> 
> asWindowsbasename(c(
+     "  test  ",
+     "  testing?.",
+     "already valid name"
+ ))
[1] "test"               "testing_"           "already valid name"
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("asWindowsbasename", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("aslength1")
> ### * aslength1
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: aslength1
> ### Title: Subset the First Element of a Vector
> ### Aliases: aslength1
> 
> ### ** Examples
> 
> aslength1(1)
[1] 1
> aslength1(1:10)
Warning in aslength1(1:10) : first element used of '1:10' argument
[1] 1
> try(aslength1(integer(0)))
Error in aslength1(integer(0)) : 'integer(0)' must be of length 1
> 
> print(system.file("R", "aslength1.Rd", package = "essentials"))
[1] ""
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("aslength1", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("color.with.alpha")
> ### * color.with.alpha
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: color.with.alpha
> ### Title: Color Opacity
> ### Aliases: color.with.alpha as.hex.code
> 
> ### ** Examples
> 
> example.colors <- c("red", "#FFA50099", "yellow", "green", "blue", "purple")
> show.colors(example.colors)
> show.colors(color.with.alpha(example.colors, alpha = NULL))  # remove all opacity
> show.colors(color.with.alpha(example.colors, alpha = 0.25))  # one quarter opaque
> show.colors(color.with.alpha(example.colors, alpha = 0.5))   # half opaque
> show.colors(color.with.alpha(example.colors, alpha = 0.75))  # three quarters opaque
> show.colors(color.with.alpha(example.colors, alpha = 1))     # fully opaque, same as NULL
> 
> 
> example.colors2 <- 1:8
> show.colors(example.colors2)
> show.colors(color.with.alpha(example.colors2, alpha = 0.5))
> show.colors(color.with.alpha(example.colors2, alpha = 0.75))
> 
> 
> example.colors3 <- grDevices::col2rgb(gg.colors(10))
> 
> 
> ## show.colors would not be able to show example.colors3 because it's a matrix
> ## use as.hex.codes to decode the values to their hex codes, then display
> show.colors(as.hex.code(example.colors3))
> show.colors(color.with.alpha(example.colors3, alpha = 0.5))
> show.colors(color.with.alpha(example.colors3, alpha = 0.75))
> 
> 
> example.colors4 <- data.frame(
+     red   = c( 75,  66,  24,   0,   0,   0,   0, 108, 187, 253)/255,
+     green = c(  0,  44,  80, 112, 142, 168, 190, 208, 221, 227)/255,
+     blue  = c( 85, 112, 134, 148, 152, 144, 125,  94,  56,  51)/255
+ )
> show.colors(as.hex.code(example.colors4))
> show.colors(color.with.alpha(example.colors4, alpha = 0.5))
> show.colors(color.with.alpha(example.colors4, alpha = 0.75))
> 
> # alpha can be a vector, here we provide 10 different alpha values
> show.colors(color.with.alpha(example.colors4,
+     alpha = seq.int(0.5, 1, length.out = 10)))
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("color.with.alpha", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("dedent")
> ### * dedent
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: dedent
> ### Title: Remove Common Leading Whitespace
> ### Aliases: dedent
> 
> ### ** Examples
> 
> cat(dedent("
+     here is a multi-line string that appears in the source code. we wish to
+     remove the common indent from each line, and dedent should do this for us!
+     ---- hopefully this works ----
+ "), sep = "\n")
here is a multi-line string that appears in the source code. we wish to
remove the common indent from each line, and dedent should do this for us!
---- hopefully this works ----
> 
> 
> # for me, a tab prints as eight spaces when preceded by a newline
> # but since tab isn't always eight spaces, we treat this as unsolveable :(
> # there is no common leading whitespace since "        " != "\t"
> cat(dedent("
+         another multi-line string, this time with no common leading whitespace
+ \tanother multi-line string, this time with no common leading whitespace
+ "), sep = "\n")
        another multi-line string, this time with no common leading whitespace
	another multi-line string, this time with no common leading whitespace
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("dedent", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("delayedAssign2")
> ### * delayedAssign2
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: delayedAssign2
> ### Title: Delay Evaluation
> ### Aliases: delayedAssign2
> 
> ### ** Examples
> 
> # this is a simplified version of what ArgumentParser does with its arguments.
> # ArgumentParser hides many details that should be shown here
> 
> 
> # make a list like ArgumentParser
> args <- list()
> add.argument <- function (name, default)
+ {
+     args[[length(args) + 1]] <<-
+         list(name = name, default = substitute(default))
+     invisible()
+ }
> 
> 
> # these would normally be added by 'ArgumentParser()$add.argument'
> add.argument("--alpha", TRUE     )
> add.argument("--beta" , `--alpha`)
> add.argument("--gamma", `--alpha`)
> 
> 
> # this would normally be the environment
> # returned by 'ArgumentParser()$parse.args'
> value <- new.env()
> 
> 
> for (n in seq_along(args)) {
+ 
+ 
+     # we have 'evaluated = TRUE' here because we don't want 'args[[n]]$default'
+     # to be the expression of the promise, but whatever 'args[[n]]$default'
+     # evaluates to
+     delayedAssign2(args[[n]]$name, args[[n]]$default,
+         eval.env = value, assign.env = value,
+         evaluated = TRUE)
+ 
+ 
+     # this part would normally be more complex to deal with things like
+     # multiple names for 1 argument, 'type', 'choices',  and, of course,
+     # providing arguments, but i only want to demonstrate 'delayedAssign2' here
+ }
> 
> 
> # then we force evaluate each argument
> for (n in seq_along(args)) {
+     get(args[[n]]$name, envir = value, inherits = FALSE)
+ }
> 
> 
> # these are all TRUE, could be all NA or FALSE if argument '--alpha=NA' or
> # '--alpha=FALSE' was provided to the ArgumentParser
> print(as.list(value, all.names = TRUE))
$`--beta`
[1] TRUE

$`--alpha`
[1] TRUE

$`--gamma`
[1] TRUE

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("delayedAssign2", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("do.while")
> ### * do.while
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: do.while
> ### Title: Do While/Until Loops in R
> ### Aliases: do.while do.until %while% %until%
> 
> ### ** Examples
> 
> # Suppose you want a unique name for a temporary file (we'll ignore that
> # `tempfile` exists for now). We can use a do while loop to create a new
> # random name until a unique name is found.
> do ({
+     value <- sprintf("%x", sample.int(2147483647L, 1L))
+     print(value)
+ }) %while% (file.exists(value))
[1] "43f85f44"
> 
> 
> ## note that the following is equivalent:
> # do ({
> #     value <- sprintf("%x", sample.int(2147483647L, 1L))
> #     print(value)
> # }) %until% (!file.exists(value))
> 
> 
> # Suppose you want a random number that is greater than one million (we'll ignore
> # that `stats::runif` exists for now).
> do ({
+     value <- sample.int(1.01e+06, 1L)
+     print(value)
+ }) %until% (value > 1e+06)
[1] 452737
[1] 124413
[1] 436523
[1] 856018
[1] 666931
[1] 25173
[1] 294762
[1] 392686
[1] 640775
[1] 538191
[1] 270373
[1] 549593
[1] 877029
[1] 284450
[1] 629118
[1] 536492
[1] 961313
[1] 203683
[1] 354634
[1] 632230
[1] 953748
[1] 772628
[1] 621100
[1] 569687
[1] 384121
[1] 474796
[1] 530807
[1] 492742
[1] 616487
[1] 150314
[1] 349464
[1] 999950
[1] 115757
[1] 122902
[1] 906982
[1] 21875
[1] 189544
[1] 353239
[1] 980460
[1] 374376
[1] 414539
[1] 13284
[1] 794408
[1] 533680
[1] 528151
[1] 909396
[1] 445469
[1] 813308
[1] 367325
[1] 744044
[1] 800405
[1] 948838
[1] 39241
[1] 441175
[1] 159350
[1] 66394
[1] 989803
[1] 622304
[1] 928871
[1] 750643
[1] 800034
[1] 628865
[1] 660411
[1] 631951
[1] 629021
[1] 493226
[1] 760319
[1] 410136
[1] 291804
[1] 376616
[1] 56659
[1] 626339
[1] 685057
[1] 798286
[1] 332614
[1] 734836
[1] 582949
[1] 837550
[1] 27075
[1] 349667
[1] 415342
[1] 186163
[1] 746545
[1] 582972
[1] 114104
[1] 386865
[1] 78071
[1] 950491
[1] 405615
[1] 244089
[1] 494643
[1] 287632
[1] 191844
[1] 104240
[1] 55084
[1] 444521
[1] 735226
[1] 804058
[1] 99522
[1] 139537
[1] 112587
[1] 924067
[1] 193198
[1] 151277
[1] 717840
[1] 481033
[1] 76380
[1] 623256
[1] 623311
[1] 199653
[1] 580256
[1] 270759
[1] 958885
[1] 831628
[1] 888334
[1] 750566
[1] 234512
[1] 926850
[1] 13824
[1] 139768
[1] 586086
[1] 61140
[1] 957061
[1] 531419
[1] 753567
[1] 323400
[1] 217393
[1] 575901
[1] 272960
[1] 49461
[1] 207722
[1] 859114
[1] 535384
[1] 274741
[1] 339558
[1] 116048
[1] 886526
[1] 810882
[1] 467838
[1] 862116
[1] 604328
[1] 270757
[1] 480184
[1] 437876
[1] 204401
[1] 650724
[1] 530505
[1] 685609
[1] 982457
[1] 380990
[1] 353924
[1] 143741
[1] 178253
[1] 556729
[1] 416409
[1] 958446
[1] 282624
[1] 786175
[1] 455708
[1] 247870
[1] 246557
[1] 936746
[1] 774120
[1] 23836
[1] 862239
[1] 784477
[1] 994604
[1] 615010
[1] 607473
[1] 11260
[1] 244149
[1] 266326
[1] 551704
[1] 280684
[1] 922894
[1] 948433
[1] 939346
[1] 18144
[1] 513589
[1] 504810
[1] 423623
[1] 692203
[1] 80640
[1] 551828
[1] 122213
[1] 818763
[1] 102516
[1] 719491
[1] 933286
[1] 906473
[1] 980636
[1] 402629
[1] 754126
[1] 284971
[1] 675793
[1] 9690
[1] 798561
[1] 189914
[1] 440644
[1] 716985
[1] 416639
[1] 379645
[1] 227792
[1] 85725
[1] 840355
[1] 623558
[1] 730279
[1] 26593
[1] 454334
[1] 57635
[1] 660109
[1] 428466
[1] 314684
[1] 593242
[1] 84804
[1] 498713
[1] 355409
[1] 520521
[1] 791022
[1] 880969
[1] 666518
[1] 195763
[1] 135329
[1] 946436
[1] 847932
[1] 10688
[1] 503989
[1] 914565
[1] 615852
[1] 146809
[1] 421789
[1] 307491
[1] 206793
[1] 455267
[1] 163988
[1] 327801
[1] 533078
[1] 192620
[1] 928274
[1] 751015
[1] 820315
[1] 200224
[1] 962611
[1] 436689
[1] 325683
[1] 448893
[1] 231513
[1] 554901
[1] 309839
[1] 143356
[1] 297664
[1] 500558
[1] 439680
[1] 663771
[1] 650654
[1] 836154
[1] 982642
[1] 984966
[1] 83733
[1] 2833
[1] 808510
[1] 302893
[1] 652456
[1] 87081
[1] 531848
[1] 483609
[1] 965524
[1] 889466
[1] 256005
[1] 614892
[1] 199863
[1] 513103
[1] 795138
[1] 47932
[1] 307770
[1] 566501
[1] 813849
[1] 202794
[1] 362107
[1] 92293
[1] 244929
[1] 389870
[1] 788744
[1] 27219
[1] 767344
[1] 15923
[1] 894694
[1] 697864
[1] 425661
[1] 191941
[1] 114677
[1] 326028
[1] 156890
[1] 72526
[1] 809119
[1] 428527
[1] 485346
[1] 874266
[1] 790192
[1] 407152
[1] 664305
[1] 696063
[1] 565896
[1] 389165
[1] 351987
[1] 741598
[1] 594078
[1] 43782
[1] 19772
[1] 799670
[1] 604546
[1] 258348
[1] 317399
[1] 353395
[1] 202844
[1] 759436
[1] 187908
[1] 969856
[1] 892826
[1] 824963
[1] 865039
[1] 830434
[1] 361907
[1] 820976
[1] 224132
[1] 991130
[1] 280277
[1] 902967
[1] 295295
[1] 486677
[1] 191322
[1] 426468
[1] 432433
[1] 364335
[1] 142064
[1] 255652
[1] 634164
[1] 266945
[1] 952293
[1] 374357
[1] 555099
[1] 706682
[1] 749172
[1] 664966
[1] 563846
[1] 242920
[1] 383457
[1] 496651
[1] 658742
[1] 298069
[1] 3328
[1] 543798
[1] 119923
[1] 920300
[1] 494295
[1] 345465
[1] 680371
[1] 644581
[1] 568578
[1] 452346
[1] 991466
[1] 471355
[1] 342435
[1] 684749
[1] 141442
[1] 472262
[1] 928311
[1] 375337
[1] 832860
[1] 774654
[1] 65282
[1] 552369
[1] 311515
[1] 655325
[1] 112229
[1] 948469
[1] 862809
[1] 281303
[1] 330672
[1] 724693
[1] 284607
[1] 565265
[1] 885793
[1] 612648
[1] 133329
[1] 245440
[1] 306519
[1] 258672
[1] 2079
[1] 287515
[1] 62913
[1] 822237
[1] 125624
[1] 243604
[1] 298470
[1] 250328
[1] 67887
[1] 220658
[1] 178772
[1] 125178
[1] 640847
[1] 889770
[1] 843644
[1] 205424
[1] 884079
[1] 814940
[1] 828659
[1] 1006087
> 
> 
> ## note that the following is equivalent:
> # do ({
> #     value <- sample.int(1.01e+06, 1L)
> #     print(value)
> # }) %while% (value <= 1e+06)
> 
> 
> # Finally suppose you wanted to ask the user for input, but wanted to make sure
> # it was valid. Here, we'll say the input is valid if it is all numeric
> # characters (ignore leading and trailing whitespace).
> # Let's put a limit on it too, only ask a certain amount of times
> count <- 0L
> do ({
+     value <- readline("Enter an integer: ")
+     value <- gsub("^\\s+|\\s$", "", value)
+     valid <- grepl("^[[:digit:]]+$", value)
+     count <- count + 1L
+ }) %until% (count >= 5L || valid)
Enter an integer: 
Enter an integer: 
Enter an integer: 
Enter an integer: 
Enter an integer: 
> print(list(value = value, valid = valid, count = count))
$value
[1] ""

$valid
[1] FALSE

$count
[1] 5

> 
> 
> ## note that the following is equivalent:
> # do ({
> #     value <- readline("Enter an integer: ")
> #     value <- gsub("^\\s+|\\s$", "", value)
> #     valid <- grepl("^[[:digit:]]+$", value)
> #     count <- count + 1L
> # }) %while% (count < 5L && !valid)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("do.while", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("envvars")
> ### * envvars
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: envvars
> ### Title: Environment Variables
> ### Aliases: envvar envvars getEnvvar
> 
> ### ** Examples
> 
> # this example runs incredibly weird using 'example', best
> # to copy and paste this text within the R console and run
> # it from there
> ## Not run: 
> ##D oenv <- envvars(); utils::str(oenv)  # oenv is a named list
> ##D 
> ##D getEnvvar("PATH") == envvars()$PATH  # the latter is slower, needs more memory
> ##D 
> ##D # change the language, and save the previous value
> ##D old.env <- envvars(LANGUAGE = "nn")
> ##D old.env              # previous value
> ##D envvars("LANGUAGE")  # current value
> ##D 
> ##D 
> ##D # restore LANGUAGE back to its previous value,
> ##D # or remove it if it previously did not exist
> ##D envvars(old.env)
> ##D 
> ##D 
> ##D envvars(oenv)  # reset (all) initial environment variables
> ##D envvars("LANGAUGE")
> ## End(Not run)
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("envvars", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("essentials-package")
> ### * essentials-package
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: essentials-package
> ### Title: Essential Functions not Included in Base R
> ### Aliases: essentials-package essentials
> ### Keywords: package
> 
> ### ** Examples
> 
> as.numbers("4")
[1] 4
> as.numbers("4+0i")  # imaginary component is removed
[1] 4
> as.numbers("4+1i")
[1] 4+1i
> 
> is.numbers(4L)
[1] TRUE
> is.numbers(4)
[1] TRUE
> is.numbers(4+1i)
[1] TRUE
> 
> as.scalar(1:100)
[1] 1
> as.scalar(as.list(1:100))  # coerced to NA_character_ since argument isn't atomic
[1] NA
> 
> aslength1(1:100)  # identical to as.scalar(1:100)
Warning in aslength1(1:100) : first element used of '1:100' argument
[1] 1
> aslength1(as.list(1:100))  # returns a list of length 1
Warning in aslength1(as.list(1:100)) :
  first element used of 'as.list(1:100)' argument
[[1]]
[1] 1

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("essentials-package", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("file.open")
> ### * file.open
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: file.open
> ### Title: Open a File or URL
> ### Aliases: file.open
> 
> ### ** Examples
> 
> ## Not run: 
> ##D file.open(tempdir())
> ##D file.open("https://cran.r-project.org/doc/manuals/R-exts.html#Documenting-packages")
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("file.open", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("flat.list")
> ### * flat.list
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: flat.list
> ### Title: Combine Values into a Flat List (a List with no List Elements)
> ### Aliases: flat.list
> 
> ### ** Examples
> 
> x <- list(a = 1:5, list(list(b = 6:10), c = 11:15), list(d = exp(-4)))
> print(x)
$a
[1] 1 2 3 4 5

[[2]]
[[2]][[1]]
[[2]][[1]]$b
[1]  6  7  8  9 10


[[2]]$c
[1] 11 12 13 14 15


[[3]]
[[3]]$d
[1] 0.01831564


> flat.list(x)
$a
[1] 1 2 3 4 5

$b
[1]  6  7  8  9 10

$c
[1] 11 12 13 14 15

$d
[1] 0.01831564

> flat.list(x, e = "testing")
$a
[1] 1 2 3 4 5

$b
[1]  6  7  8  9 10

$c
[1] 11 12 13 14 15

$d
[1] 0.01831564

$e
[1] "testing"

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("flat.list", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("hcl.colors2")
> ### * hcl.colors2
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: hcl.colors2
> ### Title: Color Palettes
> ### Aliases: hcl.colors2 inferno.colors plasma.colors viridis.colors
> ###   gg.colors show.colors
> 
> ### ** Examples
> 
> show.colors(hcl.colors2(256, palette = "Spectral"))
> 
> 
> show.colors(inferno.colors(256))
> show.colors(plasma.colors(256))
> show.colors(viridis.colors(256, end = 0.9))
> 
> 
> show.colors(gg.colors(256))
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("hcl.colors2", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("hypot")
> ### * hypot
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: hypot
> ### Title: Hypotenuse
> ### Aliases: hypot phypot
> 
> ### ** Examples
> 
> ## when a side is infinite, the hypotenuse is Inf
> hypot(Inf, NaN)   # Inf
[1] Inf
> hypot(-Inf, NaN)  # Inf (applies to negative infinity too)
[1] Inf
> 
> ## when a side is NA or NaN, the hypotenuse is NaN
> hypot(NaN, 0)     # NaN
[1] NaN
> hypot(NA , 0)     # NaN
[1] NA
> 
> ## numbers whose squares would overflow normally are handled well
> hypot(.Machine$double.xmax, 5     )
[1] 1.797693e+308
> hypot(1e+300              , 1e+300)
[1] 1.414214e+300
> 
> 
> ## hypotenuse
> hypot(3, 4)      # 5
[1] 5
> hypot(3+4i)      # 5 (works for complex numbers as well)
[1] 5
> 
> ## 3-dimensional "hypotenuse"
> hypot(3, 4, 12)  # 13
[1] 13
> 
> ## n-dimensional "hypotenuse"
> hypot(1:100)
[1] 581.6786
> 
> 
> x <- seq.int(-3, 3, length.out = 101)
> y <- 1
> (h <- phypot(x, 1))  # parallel hypotenuse
  [1] 3.162278 3.105415 3.048672 2.992056 2.935575 2.879236 2.823048 2.767020
  [9] 2.711162 2.655485 2.600000 2.544720 2.489659 2.434831 2.380252 2.325941
 [17] 2.271915 2.218197 2.164809 2.111777 2.059126 2.006888 1.955096 1.903786
 [25] 1.852998 1.802776 1.753169 1.704230 1.656019 1.608602 1.562050 1.516443
 [33] 1.471870 1.428426 1.386218 1.345362 1.305986 1.268227 1.232234 1.198165
 [41] 1.166190 1.136486 1.109234 1.084620 1.062826 1.044031 1.028397 1.016071
 [49] 1.007174 1.001798 1.000000 1.001798 1.007174 1.016071 1.028397 1.044031
 [57] 1.062826 1.084620 1.109234 1.136486 1.166190 1.198165 1.232234 1.268227
 [65] 1.305986 1.345362 1.386218 1.428426 1.471870 1.516443 1.562050 1.608602
 [73] 1.656019 1.704230 1.753169 1.802776 1.852998 1.903786 1.955096 2.006888
 [81] 2.059126 2.111777 2.164809 2.218197 2.271915 2.325941 2.380252 2.434831
 [89] 2.489659 2.544720 2.600000 2.655485 2.711162 2.767020 2.823048 2.879236
 [97] 2.935575 2.992056 3.048672 3.105415 3.162278
> graphics::plot(
+     panel.first = graphics::grid(col = "gray69"),
+     x = x, y = h, type = "l",
+     main = "Distance from" ~ (list(0, 0)) ~ "to" ~ (list(x, 1))
+ )
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("hypot", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("legend.dimensions")
> ### * legend.dimensions
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: legend.dimensions
> ### Title: Size of a Legend
> ### Aliases: legend.dimensions
> 
> ### ** Examples
> ## Don't show: 
> omar <- graphics::par("mar")
> ## End(Don't show)
> # the expression that produces the desired legend
> expr <- ~graphics::legend(
+ 
+ 
+     # the top-left corner of the legend will appear in the
+     # top-right corner of the plot
+     x = essentials::fix.xlog(graphics::par("usr")[2L]),
+     y = essentials::fix.ylog(graphics::par("usr")[4L]),
+ 
+ 
+     legend = letters[1:5], fill = 1:5,
+     xpd = TRUE
+ )
> 
> 
> # we'll start by drawing a plot with a legend without
> # adjusting the margins. the margins will likely look too
> # small or too large
> graphics::plot(1:5) ; essentials::add.legend(expr)
> 
> 
> 
> 
> 
> 
> # now, we'll adjust the margins using 'legend.dimensions'
> # capture the dimensions of the resultant legend
> ld <- essentials::legend.dimensions(expr)
> 
> 
> essentials::adj.margins(ld)
> graphics::plot(1:5) ; essentials::add.legend(expr)
> 
> 
> 
> 
> 
> # now, we'll adjust the legend such that it is centered
> # vertically
> essentials::location(expr) <- essentials::location(ld, adj = 0.5)
> graphics::plot(1:5) ; essentials::add.legend(expr)
> 
> 
> 
> 
> 
> # you do not need to use 'legend.dimensions' explicitly, you
> # could supply 'expr' directly to 'adj.margins' and
> # 'location'
> essentials::adj.margins(expr)
> essentials::location(expr) <- essentials::location(expr, adj = 0.75)
> graphics::plot(1:5) ; essentials::add.legend(expr)
> ## Don't show: 
> graphics::par(mar = omar)
> ## End(Don't show)
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("legend.dimensions", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("list.files2")
> ### * list.files2
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: list.files2
> ### Title: List the Files in a Directory/Folder
> ### Aliases: list.files2 dir2
> 
> ### ** Examples
> 
> ## Not run: 
> ##D FILE <- paste0(tempfile(tmpdir = tempfile("dir")), "_testing_\u{03B4}.txt")
> ##D dir.create(dirname(FILE))
> ##D invisible(file.create(FILE))
> ##D 
> ##D 
> ##D x <- list.files (dirname(FILE), full.names = TRUE)
> ##D y <- list.files2(dirname(FILE), full.names = TRUE)
> ##D `names<-`(file.exists(x), x)
> ##D `names<-`(file.exists(y), y)
> ##D 
> ##D 
> ##D unlink(dirname(FILE), recursive = TRUE)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("list.files2", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("listify")
> ### * listify
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: listify
> ### Title: Create a List from an Object
> ### Aliases: listify
> 
> ### ** Examples
> 
> listify(5)        # when 'x' is not a list, returns 'list(x)'
[[1]]
[1] 5

> listify(list(5))  # when 'x' is a list, returns 'x'
[[1]]
[1] 5

> 
> 
> ## when 'x' is an S4 data.frame, returns 'x'
> listify(methods::new("data.frame"))
Object of class "data.frame"
data frame with 0 columns and 0 rows
> 
> 
> ## when 'x' is an unmodified S3 data.frame, returns 'list(x)'
> listify(data.frame())
[[1]]
data frame with 0 columns and 0 rows

> 
> 
> ## S3 data.frame 'x' could be modified such that 'listify' returns 'x'
> listify(structure(data.frame(), class = c("data.frame", "list")))
data frame with 0 columns and 0 rows
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("listify", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("numbers")
> ### * numbers
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: numbers
> ### Title: Number Vectors
> ### Aliases: numbers as.numbers is.numbers as.numbers.default
> 
> ### ** Examples
> 
> x <- 1:5
> names(x) <- c("a", "b", "c", "d", "e")
> as.numbers(x)  # vector converted from integer to double, names removed
[1] 1 2 3 4 5
> 
> 
> x <- x + 0i  # x is now a complex vector
> as.numbers(x)  # vector of type double since all numbers were purely real
[1] 1 2 3 4 5
> 
> 
> ## vector of type complex, despite being purely real
> as.numbers(x, strict = FALSE)
[1] 1+0i 2+0i 3+0i 4+0i 5+0i
> 
> 
> x <- x + 1i
> ## vector remains of type complex since numbers are not purely real
> as.numbers(x)
[1] 1+1i 2+1i 3+1i 4+1i 5+1i
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("numbers", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("path.contract")
> ### * path.contract
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: path.contract
> ### Title: Contract File Paths
> ### Aliases: path.contract
> 
> ### ** Examples
> 
> stopifnot(path.contract(path.expand(x <- c("~", "~/foo"))) == x)
> # Note that this is not necessarily true the other way around (in Windows)
> # simply because the path separator may have changed
> 
> 
> tilde <- path.expand("~")
> if (tilde == "~") {
+     cat("the home directory is unknown or none is specified\n")
+ } else {
+     paths <- file.path(c(tilde, toupper(tilde), tolower(tilde)), "foo")
+     print(cbind(
+         Path = paths,
+         `Contracted Path` = path.contract(paths),
+         `Contracted Path (ignoring case)` = path.contract(paths, ignore.case = TRUE),
+         `Contracted Path (with case)` = path.contract(paths, ignore.case = FALSE)
+     ), quote = FALSE)
+ }
     Path                         Contracted Path
[1,] C:/Users/andre/Documents/foo ~/foo          
[2,] C:/USERS/ANDRE/DOCUMENTS/foo ~/foo          
[3,] c:/users/andre/documents/foo ~/foo          
     Contracted Path (ignoring case) Contracted Path (with case) 
[1,] ~/foo                           ~/foo                       
[2,] ~/foo                           C:/USERS/ANDRE/DOCUMENTS/foo
[3,] ~/foo                           c:/users/andre/documents/foo
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("path.contract", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("plapply")
> ### * plapply
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: plapply
> ### Title: Apply a Function to Multiple List or Vector Arguments
> ### Aliases: plapply psapply pvapply
> 
> ### ** Examples
> 
> plapply(list(
+     col = c("red", "green", "blue"),
+     cex = c(1, 1.5, 2),
+     main = c("title 1", "title 2", "title 3")
+ ), graphics::plot, x = 1:5, pch = 16)
[[1]]
NULL

[[2]]
NULL

[[3]]
NULL

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("plapply", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("progressBar")
> ### * progressBar
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: progressBar
> ### Title: Progress Bars
> ### Aliases: progressBar setProgressBarMethod getProgress setProgress
> ###   increment decrement
> 
> ### ** Examples
> 
> # if we use 'tryCatch', we can make use 'finally' to guarantee the progress bar
> # is closed, regardless of signalling an error or user interupt. not entirely
> # useful in this example, but it can be in longer, more complicated situations
> tryCatch({
+     pb <- progressBar(if (.Platform$OS.type == "windows")
+         "win"
+     else "txt", max = 20, style = 3)
+     for (i in 1:20) {
+         Sys.sleep(0.05)
+         increment(pb)
+     }
+ }, finally = close(pb))
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("progressBar", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("python")
> ### * python
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: python
> ### Title: Start a New Python Session
> ### Aliases: python
> 
> ### ** Examples
> 
> ## Not run: 
> ##D essentials::python(command = essentials::dedent(r"{
> ##D     print("Hello World!")
> ##D     print("An example python script...")
> ##D }"))
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("python", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("readArgs")
> ### * readArgs
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: readArgs
> ### Title: Read/Write Command-Line Arguments from/to a File
> ### Aliases: readArgs writeArgs
> 
> ### ** Examples
> 
> x <- letters; essentials::writeArgs(x, file = "")
"a" "b" "c" "d" "e" "f" "g" "h" "i" "j"
"k" "l" "m" "n" "o" "p" "q" "r" "s" "t"
"u" "v" "w" "x" "y" "z"
> 
> 
> comment(x) <- essentials::dedent("
+     adding a comment
+     to our arguments
+ "); essentials::writeArgs(x, file = "")
# adding a comment
# to our arguments
"a" "b" "c" "d" "e" "f" "g" "h" "i" "j"
"k" "l" "m" "n" "o" "p" "q" "r" "s" "t"
"u" "v" "w" "x" "y" "z"
> 
> 
> x <- list(
+ 
+ 
+     local({
+         x <- c("\xC5", "\xC9", "\xD8", "\xEC", "\xFC")
+         Encoding(x) <- "latin1"
+         comment(x) <- "accented characters"
+         x
+     }),
+ 
+ 
+     local({
+         x <- c("\u{03C3}", "\u{03B4}")
+         comment(x) <- 'greek letters (default encoding "UTF-8")'
+         x
+     }),
+ 
+ 
+     local({
+         x <- "fa\xE7ile"
+         Encoding(x) <- "latin1"  # x is intended to be in latin1
+         comment(x) <- essentials::dedent(r"{
+             another non-ASCII character ("unknown" in UTF-8 locale,
+             "latin1" in IS08859-1, ...)
+         }")
+         x
+     }),
+ 
+ 
+     local({
+         x <- c("\u{7B90}", "\u{5316}", "\u{5B57}")
+         comment(x) <- 'chinese characters (default encoding "UTF-8")'
+         x
+     }),
+ 
+ 
+     local({
+         x <- c("\U{0001D11E}", "\U{0001D4D7}")
+         comment(x) <- "rarer characters outside the usual 16^4 range"
+         x
+     }),
+ 
+ 
+     local({
+         x <- essentials::dedent(r"{
+             this would be 'rather' annoying to quote for a `shell` on $Unix$,
+             and even "more" so on Windows because of the \"double\" quotes!
+         }")
+         comment(x) <- "all ASCII characters, annoying to quote, hard to read"
+         x
+     })
+ )
> comment(x) <- essentials::dedent("
+     these are some unusual characters
+     but should still behave correctly
+ ")
> 
> 
> # the same arguments in different formats
> essentials::writeArgs(x, "", name = "Rargs")
# accented characters
""
""
""
""
""


# greek letters (default encoding "UTF-8")
"s"
"d"


# another non-ASCII character ("unknown" in UTF-8 locale,
# "latin1" in IS08859-1, ...)
"faile"


# chinese characters (default encoding "UTF-8")
"<U+7B90>"
"<U+5316>"
"<U+5B57>"


# rarer characters outside the usual 16^4 range
"<U+0001D11E>"
"<U+0001D4D7>"


# all ASCII characters, annoying to quote, hard to read
"this would be 'rather' annoying to quote for a `shell` on $Unix$,\nand even \"more\" so on Windows because of the \\\"double\\\" quotes!"
> essentials::writeArgs(x, "", name = "pyargs")
Warning in selectReadWriteArgsMethod(file, name)$write(x, comments = comments,  :
  arguments in 'pyargs' file contain newline / / carriage return,
 will not be written correctly





s
d
faile
<U+7B90>
<U+5316>
<U+5B57>
<U+0001D11E>
<U+0001D4D7>
this would be 'rather' annoying to quote for a `shell` on $Unix$,
and even "more" so on Windows because of the \"double\" quotes!
> essentials::writeArgs(x, "", name = "csv")
"","","","",""


"s","d"


"faile"


"<U+7B90>","<U+5316>","<U+5B57>"


"<U+0001D11E>","<U+0001D4D7>"


"this would be 'rather' annoying to quote for a `shell` on $Unix$,
and even ""more"" so on Windows because of the \""double\"" quotes!"
> essentials::writeArgs(x, "", name = "tsv")
""	""	""	""	""


"s"	"d"


"faile"


"<U+7B90>"	"<U+5316>"	"<U+5B57>"


"<U+0001D11E>"	"<U+0001D4D7>"


"this would be 'rather' annoying to quote for a `shell` on $Unix$,
and even ""more"" so on Windows because of the \""double\"" quotes!"
> essentials::writeArgs(x, "", name = NULL)
# accented characters
"" "" "" "" ""


# greek letters (default encoding "UTF-8")
"s" "d"


# another non-ASCII character ("unknown" in UTF-8 locale,
# "latin1" in IS08859-1, ...)
"faile"


# chinese characters (default encoding "UTF-8")
"<U+7B90>" "<U+5316>" "<U+5B57>"


# rarer characters outside the usual 16^4 range
"<U+0001D11E>" "<U+0001D4D7>"


# all ASCII characters, annoying to quote, hard to read
"this would be 'rather' annoying to quote for a `shell` on $Unix$,
and even \"more\" so on Windows because of the \\"double\\" quotes!"
> 
> 
> FILE <- essentials::writeArgs(x, at = FALSE)
> y <- essentials::readArgs(FILE)
> 
> 
> # for the purpose of comparison, we need 'x' to be a character vector
> z <- essentials:::asArgs(x)
> 
> 
> # let's check that the arguments in 'x' match the
> # arguments written to and read back from 'FILE' (in 'y')
> #
> # we don't use 'identical(x, y)' because 'x' has
> # attributes (a comment) while 'y' does not
> if (length(z) != length(y)) {
+     cat(gettextf("Catastrophic failure, wrote %d arguments, read %d\n",
+         length(z), length(y)),
+         file = stderr())
+     stop("Please submit a bug report using ",
+         "utils::bug.report(package = \"essentials\")")
+ } else if (any(i <- z != y)) {
+     cat(ngettext(sum(i),
+         "The following argument was written or read incorrectly!\n",
+         "The following arguments were written or read incorrectly!\n"),
+         file = stderr())
+     print(z[i])
+     cat("\nIncorrectly written or read as:\n", file = stderr())
+     print(y[i])
+     stop("Please submit a bug report using ",
+         "utils::bug.report(package = \"essentials\")")
+ } else cat("Yay! The arguments were written and read correctly!\n")
Yay! The arguments were written and read correctly!
> 
> 
> 
> 
> 
> # Using writeArgs and withArgs, Rscript
> cat(
+     essentials::dedent(r"{
+         withAutoprint({
+             parser <- essentials::ArgumentParser()
+             parser$add.argument("args", nargs = "*")
+             pargs <- parser$parse.args()
+             print(pargs$args)
+         })
+     }"),
+     file = script <- tempfile(), sep = "\n"
+ )
> essentials::withArgs(
+     source(script, local = TRUE, echo = FALSE),
+     paste0("@", FILE)
+ )
> parser <- essentials::ArgumentParser()
> parser$add.argument("args", nargs = "*")
> pargs <- parser$parse.args()
> print(pargs$args)
 [1] ""                                                                                                                                       
 [2] ""                                                                                                                                       
 [3] ""                                                                                                                                       
 [4] ""                                                                                                                                       
 [5] ""                                                                                                                                       
 [6] "s"                                                                                                                                       
 [7] "d"                                                                                                                                       
 [8] "faile"                                                                                                                                  
 [9] "<U+7B90>"                                                                                                                                
[10] "<U+5316>"                                                                                                                                
[11] "<U+5B57>"                                                                                                                                
[12] "<U+0001D11E>"                                                                                                                            
[13] "<U+0001D4D7>"                                                                                                                            
[14] "this would be 'rather' annoying to quote for a `shell` on $Unix$,\nand even \"more\" so on Windows because of the \\\"double\\\" quotes!"
> essentials::Rscript("--default-packages=NULL", script, args = paste0("@", FILE))
andre@DESKTOP-VR312SR:~/essentials/essentials.Rcheck/examples_x64$ Rscript "--default-packages=NULL" "C:\Users\andre\AppData\Local\Temp\Rtmpm4mB3T/working_dir\RtmpmATTxt\file43b4ed454e2" "@C:\Users\andre\AppData\Local\Temp\Rtmpm4mB3T\working_dir\RtmpmATTxt\args43b45a953708.Rargs"
> parser <- essentials::ArgumentParser()
> parser$add.argument("args", nargs = "*")
> pargs <- parser$parse.args()
> print(pargs$args)
 [1] ""                                                                                                                                       
 [2] ""                                                                                                                                       
 [3] ""                                                                                                                                       
 [4] ""                                                                                                                                       
 [5] ""                                                                                                                                       
 [6] "s"                                                                                                                                       
 [7] "d"                                                                                                                                       
 [8] "faile"                                                                                                                                  
 [9] "<U+7B90>"                                                                                                                                
[10] "<U+5316>"                                                                                                                                
[11] "<U+5B57>"                                                                                                                                
[12] "<U+0001D11E>"                                                                                                                            
[13] "<U+0001D4D7>"                                                                                                                            
[14] "this would be 'rather' annoying to quote for a `shell` on $Unix$,\nand even \"more\" so on Windows because of the \\\"double\\\" quotes!"

Process finished with exit code 0
> ## Don't show: 
> unlink(script)
> ## End(Don't show)
> 
> 
> 
> 
> # reading/writing from/to a compressed file
> FILE2 <- essentials::writeArgs(x, at = FALSE, fileext = ".Rargs.gz")
> stopifnot(identical(
+     essentials::readArgs(FILE),
+     essentials::readArgs(FILE2)
+ ))
> 
> 
> # miniscule difference, more desirable with more arguments
> c(file.size.original   = file.size(FILE),
+   file.size.compressed = file.size(FILE2))
  file.size.original file.size.compressed 
                 562                  363 
> ## Don't show: 
> unlink(FILE); unlink(FILE2)
> ## End(Don't show)
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("readArgs", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("setReadWriteArgsMethod")
> ### * setReadWriteArgsMethod
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: setReadWriteArgsMethod
> ### Title: Create and Save a Method for Reading/Writing Command-Line
> ###   Arguments from/to a File
> ### Aliases: has.ext scan2 format4scan setReadWriteArgsMethod
> 
> ### ** Examples
> 
> # suppose you wanted to define your own method for
> # reading/writing command-line arguments to a file. we'll
> # say the file extension will be ".myargs". with this, we
> # start by making 'condition'
> condition <- function(file) {
+     essentials::has.ext(file, ".myargs",
+         compression = TRUE, fixed = TRUE)
+ }
> 
> 
> # next, we will make a reading function. this will typically
> # be some variation of 'scan2', but feel free to use
> # anything else that works. for this example, we'll use
> # "-" as the delimiter, "`" as the quoting character, and
> # "/" as the comment character
> read <- function(file) {
+     essentials::scan2(file = file, sep = "-",
+         quote = "`", comment.char = "/")
+ }
> 
> 
> # next, we will make a writing function. this will typically
> # be some variation of 'format4scan', but feel free to use
> # anything else that works
> write <- function(x, comments = TRUE,
+     nlines.between.comment.and.args = 0,
+     nlines.between.args = 2) {
+     essentials::format4scan(x, sep = "-", quote = "`",
+         comment.char = if (comments) "/" else "",
+         nlines.between.comment.and.args = nlines.between.comment.and.args,
+         nlines.between.args = nlines.between.args)
+ }
> 
> 
> # now, combine it all together
> essentials::setReadWriteArgsMethod(
+     name      = "myargs",
+     condition = condition,
+     read      = read,
+     write     = write
+ )
> 
> 
> # try writing arguments with this new format
> x <- letters
> comment(x) <- "testing comments"
> essentials::writeArgs(x, "", name = "myargs")
/ testing comments
`a`-`b`-`c`-`d`-`e`-`f`-`g`-`h`-`i`-`j`
`k`-`l`-`m`-`n`-`o`-`p`-`q`-`r`-`s`-`t`
`u`-`v`-`w`-`x`-`y`-`z`
> 
> 
> # confirm that writing and reading returns the same set of
> # arguments
> FILE <- essentials::writeArgs(x, fileext = ".myargs", at = FALSE)
> y <- essentials::readArgs(FILE)
> stopifnot(length(x) == length(y), x == y)
> ## Don't show: 
> unlink(FILE)
> ## End(Don't show)
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("setReadWriteArgsMethod", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("shEncode")
> ### * shEncode
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: shEncode
> ### Title: Quote Strings for Use in OS Shells
> ### Aliases: shEncode commandEncode commandQuote
> 
> ### ** Examples
> 
> fun <- function(string) {
+     cat(c(
+         "string  ", string                                        , "\n",
+         "sh      ", essentials::shEncode(string, type = "sh"     ), "\n",
+         "Rscript ", essentials::shEncode(string, type = "Rscript"), "\n",
+         "R       ", essentials::shEncode(string, type = "R"      ), "\n"
+     ), sep = "")
+ }
> 
> fun("abc$def`gh`i\\j")
string  abc$def`gh`i\j
sh      'abc$def`gh`i\j'
Rscript "abc$def`gh`i\j"
R       "abc$def`gh`i\j"
> 
> fun("testing \\\"this\\\"")
string  testing \"this\"
sh      'testing \"this\"'
Rscript "testing \\\"this\\\""
R       "testing \\\\\\\"this\\\\\\\""
> 
> fun("\"testing\" $this$ 'out'")
string  "testing" $this$ 'out'
sh      '"testing" $this$ '"'"'out'"'"''
Rscript "\"testing\" $this$ 'out'"
R       "\\\"testing\\\" $this$ 'out'"
> 
> 
> ## Not run: 
> ##D essentials:::.system(paste(c(
> ##D     "perl",
> ##D     "-e",
> ##D     essentials::shEncode(r"{print "test \"this\" out\n";}",
> ##D         windows.type = "perl")
> ##D ), collapse = " "))
> ## End(Not run)
> 
> 
> ## Not run: 
> ##D essentials:::.system(paste(c(
> ##D     "python",
> ##D     "-c",
> ##D     essentials::shEncode(r"{print("test \"this\" out")}",
> ##D         windows.type = "python")
> ##D ), collapse = " "))
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("shEncode", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("shPrompt")
> ### * shPrompt
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: shPrompt
> ### Title: Replicate the Command-Line / / Terminal Prompts Seen on a Few
> ###   Common Shells
> ### Aliases: shPrompt
> 
> ### ** Examples
> 
> cat(
+     essentials::shPrompt("cmd"       ),
+     essentials::shPrompt("powershell"),
+     essentials::shPrompt("macOS"     ),
+     essentials::shPrompt("bash"      ),
+     sep = "\n"
+ )
C:\Users\andre\Documents\essentials\essentials.Rcheck\examples_x64>
PS C:\Users\andre\Documents\essentials\essentials.Rcheck\examples_x64> 
DESKTOP-VR312SR:examples_x64 andre$ 
andre@DESKTOP-VR312SR:~/essentials/essentials.Rcheck/examples_x64$ 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("shPrompt", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("strip")
> ### * strip
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: strip
> ### Title: Remove Leading and Trailing White Spaces
> ### Aliases: strip
> 
> ### ** Examples
> 
> x <- c(
+     "  the quick brown fox jumps over a lazy dog  ",
+     "  the quick brown fox jumps over a lazy dog\t\n"
+ )
> strip(x)  # the leading and trailing tab, newline, and space are removed
[1] "the quick brown fox jumps over a lazy dog"
[2] "the quick brown fox jumps over a lazy dog"
> 
> 
> ## x is intended to be in encoding latin1
> x <- "fa\xE7ile"
> Encoding(x) <- "latin1"
> y <- strip(x)
> 
> 
> ## since 'x' has no leading or trailing white space, 'strip(x)' retains the
> ## encoding of 'x'
> Encoding(y)
[1] "latin1"
> y
[1] "faile"
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("strip", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("toProv")
> ### * toProv
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: toProv
> ### Title: Convert the Provinces and Territories of Canada to their Names
> ###   or Postal Abbreviations
> ### Aliases: toProv toProv2 toProvince
> 
> ### ** Examples
> 
> x <- c(
+     "Ontario"                  , "ON", "0N",
+ 
+ 
+     # alternate forms
+     "Quebec"                   , "QC", "Qu\u{00E9}bec",
+ 
+ 
+     # case insensitive
+     "Nova Scotia"              , "NS", "nova scotia",
+     "New Brunswick"            , "NB",
+     "Manitoba"                 , "MB",
+     "British Columbia"         , "BC",
+     "Prince Edward Island"     , "PE", "PEI",
+ 
+ 
+     # partial matching
+     "Saskatchewan"             , "SK", "Sask",
+     "Alberta"                  , "AB", "AL",
+     "Newfoundland and Labrador", "NL", "Newfoundland & Labrador", "NF",
+     "Northwest Territories"    , "NT",
+     "Yukon"                    , "YT", "Yukon Territory", "YK",
+     "Nunavut"                  , "NU"
+ )
> cbind(Original = x, `Postal Abbr` = toProv(x), Name = toProvince(x))
      Original                    Postal Abbr Name                       
 [1,] "Ontario"                   "ON"        "Ontario"                  
 [2,] "ON"                        "ON"        "Ontario"                  
 [3,] "0N"                        "ON"        "Ontario"                  
 [4,] "Quebec"                    "QC"        "Quebec"                   
 [5,] "QC"                        "QC"        "Quebec"                   
 [6,] "Qubec"                    "QC"        "Quebec"                   
 [7,] "Nova Scotia"               "NS"        "Nova Scotia"              
 [8,] "NS"                        "NS"        "Nova Scotia"              
 [9,] "nova scotia"               "NS"        "Nova Scotia"              
[10,] "New Brunswick"             "NB"        "New Brunswick"            
[11,] "NB"                        "NB"        "New Brunswick"            
[12,] "Manitoba"                  "MB"        "Manitoba"                 
[13,] "MB"                        "MB"        "Manitoba"                 
[14,] "British Columbia"          "BC"        "British Columbia"         
[15,] "BC"                        "BC"        "British Columbia"         
[16,] "Prince Edward Island"      "PE"        "Prince Edward Island"     
[17,] "PE"                        "PE"        "Prince Edward Island"     
[18,] "PEI"                       "PE"        "Prince Edward Island"     
[19,] "Saskatchewan"              "SK"        "Saskatchewan"             
[20,] "SK"                        "SK"        "Saskatchewan"             
[21,] "Sask"                      "SK"        "Saskatchewan"             
[22,] "Alberta"                   "AB"        "Alberta"                  
[23,] "AB"                        "AB"        "Alberta"                  
[24,] "AL"                        "AB"        "Alberta"                  
[25,] "Newfoundland and Labrador" "NL"        "Newfoundland and Labrador"
[26,] "NL"                        "NL"        "Newfoundland and Labrador"
[27,] "Newfoundland & Labrador"   "NL"        "Newfoundland and Labrador"
[28,] "NF"                        "NL"        "Newfoundland and Labrador"
[29,] "Northwest Territories"     "NT"        "Northwest Territories"    
[30,] "NT"                        "NT"        "Northwest Territories"    
[31,] "Yukon"                     "YT"        "Yukon"                    
[32,] "YT"                        "YT"        "Yukon"                    
[33,] "Yukon Territory"           "YT"        "Yukon"                    
[34,] "YK"                        "YT"        "Yukon"                    
[35,] "Nunavut"                   "NU"        "Nunavut"                  
[36,] "NU"                        "NU"        "Nunavut"                  
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("toProv", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("tryExcept")
> ### * tryExcept
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: tryExcept
> ### Title: Condition Handling and Recovery
> ### Aliases: tryExcept
> 
> ### ** Examples
> 
> # the following example won't work using 'utils::example' because it signals
> # errors, so copy and paste this code into the R Console
> 
> 
> ## Not run: 
> ##D tryCatch({
> ##D     stop("error in 'expr'")
> ##D }, finally = {
> ##D     stop("tryCatch will not reach the second expression in 'finally'")
> ##D     stop("but tryExcept will")
> ##D })
> ##D 
> ##D 
> ##D essentials::tryExcept({
> ##D     stop("error in 'expr'")
> ##D }, finally = {
> ##D     stop("tryCatch will not reach the second expression in 'finally'")
> ##D     stop("but tryExcept will")
> ##D })
> ##D 
> ##D 
> ##D essentials::tryExcept({
> ##D     stop("error in 'expr'")
> ##D }, finally = {
> ##D     cat("this environment = "); print(environment())
> ##D     stop("err1")
> ##D     stop("err2")
> ##D     print(5 + 6)
> ##D     stop("err3")
> ##D 
> ##D 
> ##D     # just checking that the arguments aren't evaluated in the wrong frame
> ##D     # (why would they be though??)
> ##D     expr
> ##D     finally
> ##D 
> ##D 
> ##D     # testing that code with a source reference will be evaluated properly
> ##D     print(function(x) {
> ##D         x  # testing comments only appearing in source reference
> ##D     })
> ##D 
> ##D 
> ##D     stop("err4")
> ##D     print(6 + 7)
> ##D 
> ##D 
> ##D })
> ##D 
> ##D 
> ##D essentials::tryExcept({
> ##D     cat("this one should behave the same as tryCatch",
> ##D         "because 'finally' is not a compound expression",
> ##D         "(is not of class \"{\")",
> ##D         sep = "\n")
> ##D     stop("error in 'expr'")
> ##D }, finally =
> ##D 
> ##D 
> ##D     # checking again that 'finally' is evaluated in the correct environment
> ##D     cat("this environment =", utils::capture.output(environment()), "\n"))
> ##D 
> ##D 
> ##D essentials::tryExcept({
> ##D 
> ##D 
> ##D     cat("Here is a situation in which you might actually use this.",
> ##D         "Suppose you're changing a bunch of settings and options that you want",
> ##D         "to reset when 'tryExcept' finishes. For example:",
> ##D         "* changing the working directory",
> ##D         "* changing options stored in `options()`",
> ##D         "* changing graphical parameters stored in `graphics::par()`",
> ##D         "* shutting down a graphics device with `dev.off()`",
> ##D         "* changing the current graphics device with `dev.set()`",
> ##D         "* changing the state of `grDevices::devAskNewPage()`",
> ##D         "* deleting a temporary file created with `tempfile()`",
> ##D         "    or downloaded with `utils::download.file()`",
> ##D         "* closing a connection",
> ##D         "* changing the random number generator state",
> ##D         "    with `RNGkind()` or `set.seed()`",
> ##D         "* any other type of cleaning process",
> ##D         sep = "\n")
> ##D     owd <- getwd()
> ##D     oopt <- options(max.print = 10, digits = 17)
> ##D     odev <- grDevices::dev.cur()
> ##D     if (names(odev) != "null device")
> ##D         oldask <- grDevices::devAskNewPage(ask = FALSE)
> ##D     FILE <- tempfile()
> ##D     setwd(dirname(FILE))
> ##D     con <- file(FILE, "w")
> ##D     if (has.Random.seed <- exists(".Random.seed", envir = globalenv(), inherits = FALSE))
> ##D         oldSeed <- get(".Random.seed", envir = globalenv(), inherits = FALSE)
> ##D     else oldRNG <- RNGkind()
> ##D     RNGkind("default", "default", "default")
> ##D     set.seed(1)
> ##D 
> ##D 
> ##D     cat("\nYou've setup your settings and options above",
> ##D         "so now we do something with it", sep = "\n")
> ##D 
> ##D 
> ##D     cat("\nOnly 10 of these will print\n")
> ##D     print(1:100)
> ##D 
> ##D 
> ##D     cat("\nWe're plotting an image which we will remove afterwards\n")
> ##D     plot(1:10)
> ##D     cdev <- grDevices::dev.cur()
> ##D     Sys.sleep(2)
> ##D 
> ##D 
> ##D }, finally = {
> ##D 
> ##D 
> ##D     cat("\nNow clean up the everything, but unlike 'tryCatch', run all",
> ##D         "cleaning steps even if one signals an error", sep = "\n")
> ##D 
> ##D 
> ##D     grDevices::dev.off(cdev)
> ##D     close(con)
> ##D     file.remove(FILE)
> ##D 
> ##D 
> ##D     if (has.Random.seed)
> ##D         assign(".Random.seed", oldSeed, envir = globalenv(), inherits = FALSE)
> ##D     else RNGkind(oldRNG[1L], oldRNG[2L], oldRNG[3L])
> ##D 
> ##D 
> ##D     if (names(odev) != "null device") {
> ##D         grDevices::dev.set(oldask)
> ##D         grDevices::devAskNewPage(oldask)
> ##D     }
> ##D 
> ##D 
> ##D     setwd(owd)
> ##D     options(oopt)
> ##D })
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("tryExcept", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("withArgs")
> ### * withArgs
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: withArgs
> ### Title: Source R Code, Providing Arguments to the Script
> ### Aliases: withArgs
> 
> ### ** Examples
> 
> essentials:::write.code(file = FILE <- tempfile(), {
+     withAutoprint({
+ 
+ 
+         this.path::this.path()
+         essentials::Args()
+ 
+ 
+     }, verbose = FALSE)
+ })
> 
> 
> # wrap your source call with a call to `withArgs`
> essentials::withArgs(
+     source(FILE, local = TRUE, verbose = FALSE),
+     letters, pi, exp(1)
+ )
> this.path::this.path()
[1] "C:/Users/andre/AppData/Local/Temp/Rtmpm4mB3T/working_dir/RtmpmATTxt/file43b4558116ab"
attr(,"this.path.n")
[1] 2
> essentials::Args()
 [1] "a"                  "b"                  "c"                 
 [4] "d"                  "e"                  "f"                 
 [7] "g"                  "h"                  "i"                 
[10] "j"                  "k"                  "l"                 
[13] "m"                  "n"                  "o"                 
[16] "p"                  "q"                  "r"                 
[19] "s"                  "t"                  "u"                 
[22] "v"                  "w"                  "x"                 
[25] "y"                  "z"                  "3.1415926535897931"
[28] "2.7182818284590451"
> essentials::withArgs(
+     sys.source(FILE, environment()),
+     letters, pi + 1i * exp(1)
+ )
> this.path::this.path()
[1] "C:/Users/andre/AppData/Local/Temp/Rtmpm4mB3T/working_dir/RtmpmATTxt/file43b4558116ab"
attr(,"this.path.n")
[1] 2
> essentials::Args()
 [1] "a"                                     
 [2] "b"                                     
 [3] "c"                                     
 [4] "d"                                     
 [5] "e"                                     
 [6] "f"                                     
 [7] "g"                                     
 [8] "h"                                     
 [9] "i"                                     
[10] "j"                                     
[11] "k"                                     
[12] "l"                                     
[13] "m"                                     
[14] "n"                                     
[15] "o"                                     
[16] "p"                                     
[17] "q"                                     
[18] "r"                                     
[19] "s"                                     
[20] "t"                                     
[21] "u"                                     
[22] "v"                                     
[23] "w"                                     
[24] "x"                                     
[25] "y"                                     
[26] "z"                                     
[27] "3.1415926535897931+2.7182818284590451i"
> 
> 
> # with R >= 4.1.0, use the forward pipe operator `|>` to
> # make calls to `withArgs` more intuitive:
> # source(FILE, local = TRUE, verbose = FALSE) |> essentials::withArgs(
> #     letters, pi, exp(1)
> # )
> # sys.source(FILE, environment()) |> essentials::withArgs(
> #     letters, pi + 1i * exp(1)
> # )
> ## Don't show: 
> unlink(FILE)
> ## End(Don't show)
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("withArgs", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("wrapper")
> ### * wrapper
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: wrapper
> ### Title: Wrapper Functions
> ### Aliases: wrapper
> 
> ### ** Examples
> 
> # I don't particularly like that the function data.frame has
> # the formal argument "check.names" default to TRUE. Here, we
> # will use 'wrapper' to make a wrapper for data.frame that has
> # "check.names" set to FALSE
> 
> 
> # we want the function body to look like this
> wrapper(data.frame)
base::data.frame(..., row.names = row.names, check.rows = check.rows, 
    check.names = check.names, fix.empty.names = fix.empty.names, 
    stringsAsFactors = stringsAsFactors)
> 
> 
> ## make the function with the appropriate function body
> data.frame2 <- function() NULL
> body(data.frame2) <- wrapper(data.frame)
> 
> 
> ## add the function formals, changing "check.names" from TRUE to FALSE
> formals(data.frame2) <- formals(data.frame)
> formals(data.frame2)$check.names <- FALSE
> 
> 
> print(data.frame2)
function (..., row.names = NULL, check.rows = FALSE, check.names = FALSE, 
    fix.empty.names = TRUE, stringsAsFactors = FALSE) 
base::data.frame(..., row.names = row.names, check.rows = check.rows, 
    check.names = check.names, fix.empty.names = fix.empty.names, 
    stringsAsFactors = stringsAsFactors)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("wrapper", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("zplapply")
> ### * zplapply
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: .plapply
> ### Title: Apply a Function to Multiple List or Vector Arguments
> ### Aliases: .plapply .psapply .pvapply
> 
> ### ** Examples
> 
> # you should see here that plapply will not evaluate its
> # optional arguments to FUN (because they are not used in
> # this example)
> #
> # but .plapply will evaluate its optional arguments, even
> # though they are not used in this example
> invisible(essentials:: plapply(NA, function(...) {
+     print(substitute(list(...)))
+ },      k = cat("evaluated optional arguments to FUN\n") ))
list(X[[1L]][[1L]], k = cat("evaluated optional arguments to FUN\n"))
> invisible(essentials::.plapply(NA, function(...) {
+     print(substitute(list(...)))
+ }, list(k = cat("evaluated optional arguments to FUN\n"))))
evaluated optional arguments to FUN
list(X[[1L]][[1L]], k = dots[[1L]])
> 
> 
> # also, plapply will only evaluate optional arguments as
> # requested
> invisible(essentials:: plapply(NA, function(x, ...) ..1,
+          cat("evaluated first optional argument to FUN\n"),
+          cat("evaluated second optional argument to FUN\n") ))
evaluated first optional argument to FUN
> invisible(essentials::.plapply(NA, function(x, ...) ..1,
+     list(cat("evaluated first optional argument to FUN\n"),
+          cat("evaluated second optional argument to FUN\n"))))
evaluated first optional argument to FUN
evaluated second optional argument to FUN
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("zplapply", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  2.55 0.1 5.08 NA NA 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
